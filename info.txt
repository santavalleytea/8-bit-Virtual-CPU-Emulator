1. Create CPU Struct
- Virtual CPU needs to store its internal states:
i.e. registers, memory, PC, SP, flags etc.

2. Load program into RAM and Fetching Instructions
- Loads a program (binary) into RAM
- Starts with program counter PC = 0
- Repeats the following loop:
    - fetch instruction at PC
    - decode binary
    - execute
    - move PC forward unless it is a JMP
- Note that cpu is a pointer to the struct CPU
- Additionally, when working with the actual struct (i.e. cpu like in main.c), 
then you can use cpu.halted, cpu.register etc. if cpu is passed as a pointer (i.e. *cpu), 
then use cpu->halted, cpu->register etc.

3. Decode and Execute Instructions
- Ceate cpu_step() function to fetch, decode and execute
- LOAD R0, 5 means store value 5 into R0
- When we encounter 0x10
    - fetch the next bite -> register number (0 for R0)
    - fetch another byte -> value to load
    - store that value in chosen register

4. Add Arithmetic Operations
- e.g. ADD R0, R1 means R0 = R0 + R1, that is, take the value from R1, add to value
of R0 and store the sum in R0.
- 0x20 for ADD, 0x00 destination register R0, 0x01 source register R1

5. Comparison and Conditional Jumps
- CMP Rx, Ry; compare two registers, if equal then set the zero flag
    - cpu->flag_zero = 1, else cpu->flag_zero = 0
    - encoded as 0x30 reg_x reg_y
- JE addr; jump if equal 
    - if the zero flag is set, jump to the instruction at the given address
    - encoded as 0x40 adrress

6. Unconditional JMP implementation
- Sets program counter to addr
- encoded as 0x41 0x0A

7. Function Calls and Stacks
- CALL 0x10 jumps to address 0x10 but remembers where to return.
- RET pops the return address and jumps back.
- Use sp as stack pointer and implementing stack.

8. Push and Pop Operations
- 